---
layout: default
title: Valinor framework home
---

<h2>Motivation</h2>
<p>
  &diams; While existing network verification tools focus almost exclusively on different variants of reachability, can we verify <b>liveness properties</b> at scale? <br><br>
  &diams; Given a <b>combinational property</b>, i.e., a property that falls under both safety and liveness criteria, can we decompose it to <b>safety-only</b> and <b>liveness-only</b> properties? <br><br>
  &diams; Can we verify the <b>latency</b> of modern large-scale networks with <b>packet-level granularity</b>?
</p>
<p>
  Below, we highlight the <a href="http://soudeh.net/#research">research</a> conducted by <a href="http://soudeh.net/#bio">our team</a> to answer these questions.
</p>
<hr/>
<h2>Scalable liveness verification</h2>
<p>
  We argue that the goal of verifying liveness properties is achievable using a <b>top-down function-oriented strategy</b> that rethinks network abstractions with the efficiency of verification in mind.

  <br><br>
  Contributions:
  <ul class="val-list-parent">
    <li class="val-list"><b>Abstraction:</b> We provide network programmers with a simple, familiar abstraction of one big switch to express their intent. This abstraction enforces the logical separation of different network functions.</li>
    <li class="val-list"><b>Packet-less model:</b> We model the program as a compact packet-less data structure that abstracts away the explicit notion of packets and focuses instead on the entities responsible for implementing functions (packet handling rules).</li>
    <li class="val-list"><b>P4 compiler:</b> We provide a compiler that translates the programs written using our abstraction to P4 programs.</li>
  </ul>
  
</p>

<h3>Our abstraction is expressive.</h3>
<p>
  Our one big switch abstraction is designed to be capable of performing similar computations and is therefore 
  expressive enough to program a wide range of network functions. Table below lists the
  functions of a few common control planes and recent network
  abstractions that we re-wrote on top of our abstraction <br><br>
  <img src="verified_list.png" class="design-figure" alt="Verified properties">
</p>

<h3>Our model is fast.</h3>
<p>
  Below, Figure (a) and (b) show examples for a UDP flood mitigation function which deploys a per-source IP counter that is incremented for every UDP
  packet and starts dropping packets when the counter exceeds a threshold. Figure (c) and (d) show examples for an “absence” property 
  (host A is never reachable) and “universality” (A is always reachable), respectively. The results demonstrate that packet-less verification 
  significantly reduces the verification time of different properties for a flood mitigation function.
  <br><br>
  <img src="liveness_result.png" class="design-figure" alt="Packet-less verification time">
</p>

<p>
  More details can be found in our paper: <a href="https://www.usenix.org/conference/nsdi20/presentation/yousefi">Liveness Verification of Stateful Network Functions
  </a>. <br><br>
</p>

<hr/>
<h2>Property decomposition</h2>
<p>
  
Existing network verifiers can be categorized by the type of network property they verify, which can either belong to safety properties or 
  liveness properties. However, network specifications do not easily fall into either of these categorizes and are composed of both safety and 
  liveness elements. Therefore, it is important to decompose network specifications into their safety and liveness components, which we solve 
  in this work using an automata-theoric approach.
  <br><br>
  Contributions:
  <ul class="val-list-parent">
    <li class="val-list"><b>Buchi Automata Representation:</b> Characterize a set of network properties that encompass safety and liveness, 
      provide their representation in the form of Buchi automata and provide their decomposed components of safety and liveness. </li>
    <li class="val-list"><b>Decomposition Tool:</b> Create a tool that allows a user to input a network property in the form of Buchi automata 
      and then returns the decomposed safety and liveness property of the original property. The decomposition is based on the automata-theoric 
      approach adapted from distributed systems..</li>
    <li class="val-list"><b>Basic Verification Model:</b> Implement a basic verification model, that takes a network snapshot and uses it to 
      verify whether the individual safety and liveness properties are met.</li>
  </ul>
The architecture of our Tool:
  <br><br>
  <img src="property_decomposition.png" class="design-figure" alt="Decomposition Tool Architecture">
</p>

<h3>Characterizing Safety and Liveness</h3>
<p>
  <i>Safety</i> properties are characterized as ones which proscribe a "bad thing", or simply put they ensure the system deliver the correct 
  output and does not fail. In terms of networks, properties such as "Host S reaches Host D only after passing a waypoint W" or "A firewall 
  blacklists the outside Host A if it tries to initiate a communication with an inside Host B".
  <br>
  <i>Liveness</i> properties stipulate that "good things" eventually happen, in terms of a program running it means that the program eventually 
  termintates. Exemplifying liveness properties in computer networks would be that, "Host S eventually finds a path to Host D that passes 
  through the waypoint W", or "a firewall eventually whitelists an outside Host A, if an inside Host B initiates a communication with it".
</p>

<h3>Expressive Representation of properties using our tool.</h3>
<p>
  Our tool succesfully provides a way to express network properties as Buchi automata, by using the interfaced parameters. Following figure represents 
  the Buchi automata that a user can input using our tool, the automata fully encapsulates the requirements of the waypoint example mentioned above, 
  that is an input is only accepted when it reaches from S to D by passing through W, moreover the accepting state would be visited infinitely 
  which fulfils the Buchi automata requirement.:<br><br>
  <img src="waypoint_tool.png" class="design-figure" alt="Waypoint Automata">
</p>

<h3>Successful decomposition of property done by our tool.</h3>
<p>
  Following two automata represent the output safety and liveness component of the waypoint property. First specifies safety, that it only rejects 
  the "bad thing" that is S reaching D without passing through W, the second specifies liveness, which accepts all inputs that reach D, with or 
  without passing W, becaues it waits for the "good" thing to eventually happen, for S to pass through W before it reaches D.:<br><br>
  <img src="waypoint_tool_s_l.png" class="design-figure" alt="Waypoint Automata Saftery and Liveness Decomposed">
</p>

<h3>Successful Verification of decomposed properties</h3>
<p>
  We tested the tool with different network graphs and it succesfully verifies whether the safety and bounded liveness properties are met by traversing 
  the network and using the decomposed Buchi automata.
</p>

<hr/>
<h2>Packet-level latency verification</h2>
<p>
  Albeit faster than their current simulation-based counterparts, the state-of-the-art verifiers today
  have major limitations such as not modeling failures or latency that prevent
  them from reliably verifying latency. We bridge this gap by proposing a scalable latency verification
  method that refines advanced abstract network models to enable fast latency verification.
  <br><br>
  Contributions:
  <ul class="val-list-parent">
    <li class="val-list"><b>Temporal verification:</b> We decompose the latency verification task
      into two phases: (i) functional verification, in which we
      compute the probability of two nodes being reachable under various network states, and (ii) temporal verification, in
      which we calculate the probability of reaching a node
      from another one below the user-specified latency bound.</li>
    <li class="val-list"><b>Optimization:</b> We propose novel caching mechanisms that speed up the verification process.</li>
    <li class="val-list"><b>Implementation:</b> We implement our verifier, i.e., Tempus, in Julia and evaluate it under various scales of datacenter and wide area networks..</li>
  </ul>
  <br>
  The architecture of Tempus:
  <br><br>
  <img src="tempus_arch.png" class="design-figure" alt="Tempus's architecture">
</p>

<h3>Tempus is fast.</h3>
<p>
  We run Tempus on various scales of k-ary fat-tree topology with 100 Gbps links under 25%
  load and compare the verification time with the time taken for simulating all failure scenarios using the state-of-the-art
  network simulators. For this purpose, we use OMNeT++ (a non-parallel packet-level network simulator), Parsimon (a parallel flow-level simulator), and DONS
  (a parallel packet-level simulator). We observe that tempus is orders of magnitude faster than all these simulators:<br><br>
  <img src="tempus_fast.png" class="design-figure" alt="Tempus is fast">
  
  ''αy βmo γd δh ηmin κs’’ represents α years, β months, γ days, δ hours, η minutes, and κ seconds.
</p>

<h3>Tempus is accurate.</h3>
<p>
  To evaluate the accuracy of Tempus, we simulate the
  no-failure scenario and various degrees of load in a two-tier leaf-spine topology using
  OMNeT++ and measure the tail (99th percentile) packet-level delay. We repeat the
  simulations ten times to capture various randomnesses caused
  by the simulator. For Tempus, we input the network topology
  and the empirical queueing time measurements from our
  simulations and record the tail latency estimated
  by Tempus for the no-failure scenario. We observe that,
  irrespective of the load, Tempus accurately captures the upper
  limit for the tail delay:<br><br>
  <img src="tempus_accurate.png" class="design-figure" alt="Tempus is accurate">
  The box and whisker plots represent distinct tail latencies
  recorded as we repeat the simulations multiple times.
</p>

<p>
  More details can be found in our paper: <a href="">Tempus: Probabilistic Network Latency Verification</a>. 
  <br>
  For the codebase, please refer to the <a href="https://github.com/hopnets/Tempus">Github page of Tempus</a>. 
  <br><br>
</p>

<div class="listing">
    {% for post in paginator.posts %}
    <div class="post other link">
      <h2></span> <a href="{{site.url}}{{post.url}}">{{ post.title }}</a></h2>
      <p class="post-date">{{ post.date | date_to_string }}</p>
      {{ post.excerpt }}
    </div>
    {% endfor %}
</div>
